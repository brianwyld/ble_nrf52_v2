/**
 * Copyright (c) 
 */
#include <stdint.h>
#include <string.h>
#include <inttypes.h>

#include "wutils.h"

#include "sdk_common.h"
#include "ble.h"
#include "nrf_sdh_ble.h"
#include "ble_srv_common.h"

#include "ble_wakehost.h"

#define APP_BLE_OBSERVER_PRIO           3                                           /**< Application's BLE observer priority. You shouldn't need to modify this value. */

#define BLE_WAKEUP_MAX_WAKEUP_CHAR_LEN        2                 /**< Maximum length of the WKAEUP Characteristic (in bytes). */
// Infrafon UUID for this service
// generated by https://www.guidgenerator.com/online-guid-generator.aspx : EAD210B7-F3EA-4A35-A223-9802AC9C53DF
#define WAKEUP_BASE_UUID                  {{0xEA, 0xD2, 0x10, 0xB7, 0xF3, 0xEA, 0x4A, 0x35, 0xA2, 0x23, 0x98, 0x02, 0xAC, 0x9C, 0x53, 0xDF}} /**< Used vendor specific UUID. */
#define BLE_UUID_WAKEUP_SERVICE         0x0001              /** UUID of WAKEUP service - replaces bytes 3/4 of the base UUID */
#define BLE_UUID_WAKEUP_CHARACTERISTIC  0x0002               /**< The UUID of the WAKEUP Characteristic - replaces bytes 3 and 4 of the base UUID. */

static struct {
    uint8_t                         uuid_type;          /**< UUID type for Service Base UUID. */
    uint16_t                        service_handle;     /**< Handle of Service (as provided by the SoftDevice). */
    ble_gatts_char_handles_t        wakeup_handles;         /**< Handles related to the WAKEUP characteristic (as provided by the SoftDevice). */
    ble_wakeup_handler_t            wakeup_handler;       /**< Event handler to be called when wakeup requested. */
} _ctx;

// Register a handler for BLE events.
static void ble_wakeup_on_ble_evt(ble_evt_t const * p_ble_evt, void * p_context);
NRF_SDH_BLE_OBSERVER(m_ble_wakeup_observer, APP_BLE_OBSERVER_PRIO, ble_wakeup_on_ble_evt, &_ctx);

/**@brief Function for handling the @ref BLE_GAP_EVT_CONNECTED event from the SoftDevice.
 *
 * @param[in] p_nus     Nordic UART Service structure.
 * @param[in] p_ble_evt Pointer to the event received from BLE stack.
 */
static void on_connect(ble_evt_t const * p_ble_evt)
{
    // noop here
}


/**@brief Function for handling the @ref BLE_GATTS_EVT_WRITE event from the SoftDevice.
 *
 * @param[in] p_ble_evt Pointer to the event received from BLE stack.
 */
static void on_write(ble_evt_t const * p_ble_evt)
{
    ble_gatts_evt_write_t const * p_evt_write = &p_ble_evt->evt.gatts_evt.params.write;
    if ((p_evt_write->handle == _ctx.wakeup_handles.value_handle) &&
             (_ctx.wakeup_handler != NULL))
    {
        _ctx.wakeup_handler(p_evt_write->data, p_evt_write->len);
    }
    else
    {
        // Do Nothing. This event is not relevant for this service.
    }
}


static void ble_wakeup_on_ble_evt(ble_evt_t const * p_ble_evt, void * p_context)
{
    if (p_ble_evt == NULL) {
        return;
    }

    switch (p_ble_evt->header.evt_id)
    {
        case BLE_GAP_EVT_CONNECTED:
            on_connect(p_ble_evt);
            break;

        case BLE_GATTS_EVT_WRITE:
            on_write(p_ble_evt);
            break;

        default:
            // No implementation needed.
            break;
    }
}


uint32_t ble_wakeup_init(ble_wakeup_handler_t whandler)
{
    ret_code_t            err_code;
    ble_uuid_t            ble_uuid;
    ble_uuid128_t         wakeup_base_uuid = WAKEUP_BASE_UUID;
    ble_add_char_params_t add_char_params;

    // Initialize the service structure.
    _ctx.wakeup_handler = whandler;

    /**@snippet [Adding proprietary Service to the SoftDevice] */
    // Add a custom base UUID.
    err_code = sd_ble_uuid_vs_add(&wakeup_base_uuid, &_ctx.uuid_type);
    APP_ERROR_CHECK(err_code);

    ble_uuid.type = _ctx.uuid_type;
    ble_uuid.uuid = BLE_UUID_WAKEUP_SERVICE;

    // Add the service.
    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY,
                                        &ble_uuid,
                                        &_ctx.service_handle);
    /**@snippet [Adding proprietary Service to the SoftDevice] */
    APP_ERROR_CHECK(err_code);

    // Add the WAKEUP Characteristic.
    memset(&add_char_params, 0, sizeof(add_char_params));
    add_char_params.uuid                     = BLE_UUID_WAKEUP_CHARACTERISTIC;
    add_char_params.uuid_type                = _ctx.uuid_type;
    add_char_params.max_len                  = BLE_WAKEUP_MAX_WAKEUP_CHAR_LEN;
    add_char_params.init_len                 = BLE_WAKEUP_MAX_WAKEUP_CHAR_LEN;
    add_char_params.is_var_len               = false;
    add_char_params.char_props.write         = 1;
    add_char_params.char_props.write_wo_resp = 1;

    add_char_params.read_access  = SEC_OPEN;
    add_char_params.write_access = SEC_OPEN;

    err_code =  characteristic_add(_ctx.service_handle, &add_char_params, &_ctx.wakeup_handles);
    APP_ERROR_CHECK(err_code);

    return NRF_SUCCESS;
}

void ble_wakeup_getuuid(ble_uuid_t* p_uuid) {
    p_uuid->type = _ctx.uuid_type;
    p_uuid->uuid = BLE_UUID_WAKEUP_SERVICE;
}
